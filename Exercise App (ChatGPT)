<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Exercise App — DNA Melting Curves (Configurable)</title>
  <style>
    :root {
      --bg: #0b1020;         /* deep navy */
      --bg2: #0f172a;        /* slate-900 */
      --panel: #0c1222;      /* panel base */
      --muted: #9ca3af;      /* gray-400 */
      --text: #e5e7eb;       /* gray-200 */
      --accent: #38bdf8;     /* sky-400 */
      --accent-2: #a78bfa;   /* violet-400 */
      --ok: #22c55e;         /* green-500 */
      --warn: #ef4444;       /* red-500 */
      --thumb: 12px;         /* slider thumb (for geometry) */
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0; color: var(--text);
      background: radial-gradient(1400px 800px at 15% -10%, #0f172a 0%, transparent 60%),
                  radial-gradient(900px 600px at 85% 110%, #0f172a 0%, transparent 50%),
                  linear-gradient(180deg, var(--bg2), var(--bg));
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    body {
      margin: 0; color: var(--text);
      background: radial-gradient(1400px 800px at 15% -10%, #16223e 0%, transparent 60%),
                  radial-gradient(900px 600px at 85% 110%, #1b0b35 0%, transparent 50%),
                  linear-gradient(180deg, var(--bg2), var(--bg));
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    }
    .wrap { max-width: 1200px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 26px; margin: 8px 0 2px; letter-spacing: 0.2px; }
    .sub { color: var(--muted); margin-bottom: 18px; }

    .layout { display: grid; grid-template-columns: 380px 1fr; gap: 18px; align-items: start; }
    .card { position: relative; overflow: hidden; background: linear-gradient(180deg, rgba(15,23,42,0.85), rgba(11,18,32,0.85)); border: 1px solid rgba(255,255,255,0.08); border-radius: 16px; }
    .card .hd { padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.06); font-weight: 700; color: #cbd5e1; display:flex; align-items:center; justify-content:space-between }
    .card .bd { padding: 14px 16px; }

    label { display:block; font-size: 13px; color: #cbd5e1; margin: 10px 0 6px; }
    textarea, input, select { width: 100%; background: #0b1220; border: 1px solid rgba(255,255,255,0.08); color: var(--text); border-radius: 12px; padding: 10px 12px; font-size: 14px; }

    .row { display:flex; gap:10px; align-items:center }
    .stack { display:flex; flex-wrap:wrap; gap:10px; }
    .ghost { background: transparent; border: 1px solid #273245; color: var(--text); }
    .btn { background: linear-gradient(135deg, var(--accent), var(--accent-2)); color: white; border: none; padding: 10px 14px; border-radius: 10px; cursor: pointer; font-weight: 700; }
    .btn:disabled { opacity: .6; cursor:not-allowed }

    /* Plot & slider */
    canvas { width: 100%; height: 320px; display:block; background: #0b1220; border-radius: 12px; border: 1px solid rgba(255,255,255,0.08); margin-bottom: 12px; will-change: transform; }
    #temp {
      -webkit-appearance: none; appearance: none; width: 100%; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; padding: 0; margin: 0; display: block;
    }
    #temp::-webkit-slider-runnable-track { height:6px; background: rgba(255,255,255,0.2); border-radius:3px; margin:0 }
    #temp::-moz-range-track { height:6px; background: rgba(255,255,255,0.2); border-radius:3px; margin:0 }
    #temp::-webkit-slider-thumb { -webkit-appearance:none; appearance:none; width: var(--thumb); height: var(--thumb); border-radius: 50%; background: #38bdf8; cursor: pointer; margin-top: calc(-1 * (var(--thumb) - 6px)/2); }
    #temp::-moz-range-thumb { width: var(--thumb); height: var(--thumb); border-radius: 50%; background: #38bdf8; cursor: pointer; }

    .slider-caption { margin-top: 6px; text-align: center; }
    .legend { text-align:center; margin-top:4px; font-size:12px; color: var(--muted); }

    /* Q&A */
    .qa { border-top: 1px dashed #273245; margin-top: 12px; padding-top: 12px; }
    .qa .q { margin-bottom: 12px; }
    .muted { color: var(--muted) }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; }

    .badge { display:inline-flex; align-items:center; gap:6px; padding: 2px 8px; border-radius: 999px; background:#0a1020; border:1px solid #223047; color: var(--muted); font-size: 12px; }
    .good { color: var(--ok) }
    .bad { color: var(--warn) }
    .seqbox { background:#0b1220; border:1px solid #273245; border-radius:10px; padding:10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; font-size:12.5px; line-height:1.35; color:#d1d5db; white-space:pre-wrap; word-break:break-word; max-height:150px; overflow:auto; }
    .bad { color: var(--warn) }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Exercise App — DNA Melting Curves <span class="muted">(Configurable, Randomized)</span></h1>
    <div class="sub">Uses <b>App1</b> nearest‑neighbor engine for plotting and a configurable exercise system with random sequence generation, GC control, and scenario prompts.</div>

    <div class="layout">
      <!-- Left: Controls / Config -->
      <div class="card">
        <div class="hd">
          <span>Configuration</span>
          <span class="badge">v1</span>
        </div>
        <div class="bd">
          <label for="scenario">Scenario</label>
          <select id="scenario"></select>

          <div class="row">
            <div style="flex:1">
              <label for="len">Sequence length (≥20)</label>
              <input id="len" type="number" value="36" min="20" max="80" />
            </div>
            <div style="flex:1">
              <label for="mut">Mutations</label>
              <input id="mut" type="number" value="1" min="1" max="3" />
            </div>
          </div>

          <div class="row">
            <div style="flex:1">
              <label for="gc">GC target</label>
              <input id="gc" type="number" value="0.50" step="0.01" min="0.30" max="0.70" />
            </div>
            <div style="flex:1">
              <label for="gctol">GC tolerance ±</label>
              <input id="gctol" type="number" value="0.10" step="0.01" min="0.02" max="0.30" />
            </div>
          </div>

          <label for="randomize">Randomize on start</label>
          <select id="randomize">
            <option value="true" selected>Yes</option>
            <option value="false">No</option>
          </select>

          <div class="stack" style="margin-top:10px">
            <button class="btn" id="newset">Generate New Set</button>
            <button class="btn ghost" id="swap">Flip Curves (A↔B)</button>
          </div>

          <div class="qa">
            <div class="row" style="justify-content:space-between">
              <div class="badge">Exercise</div>
              <div class="muted" id="exId">—</div>
            </div>
            <div id="prompt" style="margin-top:8px"></div>
            <div id="questions" class="q"></div>
            <div class="stack" style="margin-top:10px">
              <button class="btn ghost" id="hint">Hint</button>
            </div>
            <div id="hintModal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,.6); align-items:center; justify-content:center; z-index:50;">
              <div style="background:#0b1220; border:1px solid #273245; border-radius:12px; padding:16px; width:min(520px,90vw)">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px">
                  <div style="font-weight:700">Hint</div>
                  <button class="btn ghost" id="closeHint">Close</button>
                </div>
                <div id="hintContent" class="muted"></div>
              </div>
            </div>
            <div class="stack" style="margin-top:10px">
              <button class="btn" id="submit">Submit Answers</button>
              <span id="score" class="muted"></span>
            </div>
          </div>
        </div>
      </div>

      <!-- Right: Visualization (App1 engine reused) -->
      <div class="card">
        <div class="hd">
          <span>Visualization</span>
          <div class="stack"><span class="badge">A: Wild‑type (WT)</span><span class="badge">B: Variant (mutant)</span><a class="btn ghost" id="umelt" href="https://www.dna-utah.org/umelt/quartz/" target="_blank" rel="noopener noreferrer">uMelt ↗</a></div>
        </div>
        <div class="bd">
          <canvas id="chart"></canvas>
          <div class="slider-block">
            <input id="temp" type="range" min="20" max="100" step="0.5" value="70" />
            <div class="slider-caption">Temperature: <span id="tLabel">70</span>°C</div>
          </div>
          <div class="legend">Overlayed curves — A (<span style="color:#38bdf8">sky</span>) & B (<span style="color:#a78bfa">violet</span>) · Estimated ΔTm: <span id="deltaTm">—</span></div>
          <div class="qa" id="seqPanel" style="margin-top:12px">
            <div class="row" style="justify-content:space-between; align-items:center">
              <div class="badge">Sequences</div>
              <div class="muted">Tip: copy a sequence and try it in uMelt</div>
            </div>
            <div class="row" style="gap:12px; margin-top:8px">
              <div style="flex:1">
                <div class="muted" style="margin-bottom:4px">A (WT) • GC: <span id="gcA">—</span></div>
                <pre class="seqbox" id="seqA">—</pre>
              </div>
              <div style="flex:1">
                <div class="muted" style="margin-bottom:4px">B (Variant) • GC: <span id="gcB">—</span></div>
                <pre class="seqbox" id="seqB">—</pre>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
  /* =============================
   * 1) App1 simulator (extracted)
   *    exposed as window.Simulator
   *    — supports overlay for A/B
   * ============================= */
  (function(){
    const NN = {
      'AA': [-7.9, -22.2], 'TT': [-7.9, -22.2],
      'AT': [-7.2, -20.4], 'TA': [-7.2, -21.3],
      'CA': [-8.5, -22.7], 'TG': [-8.5, -22.7],
      'GT': [-8.4, -22.4], 'AC': [-8.4, -22.4],
      'CT': [-7.8, -21.0], 'AG': [-7.8, -21.0],
      'GA': [-8.2, -22.2], 'TC': [-8.2, -22.2],
      'CG': [-10.6, -27.2], 'GC': [-9.8, -24.4],
      'GG': [-8.0, -19.9], 'CC': [-8.0, -19.9]
    };
    const R = 1.987; const log10 = (x)=> Math.log(x)/Math.LN10;

    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');
    const tempEl = document.getElementById('temp');
    const tLabel = document.getElementById('tLabel');
    const deltaEl = document.getElementById('deltaTm');

    const state = {
      Tmin: 20, Tmax: 100,
      datasets: [] // {label:'A'|'B', seq, tms, color}
    };

    function computeTm(subseq, concM, saltM){
      let dH = 0.2; let dS = -5.7;
      if (subseq.length < 2) return NaN;
      const first = subseq[0], last = subseq[subseq.length-1];
      if (first==='A'||first==='T'){ dH += 2.3; dS += 4.1; }
      if (last ==='A'||last ==='T'){ dH += 2.3; dS += 4.1; }
      for (let i=0;i<subseq.length-1;i++){
        const dinuc = subseq[i]+subseq[i+1]; const p = NN[dinuc]; if (!p) return NaN; dH += p[0]; dS += p[1];
      }
      const Ct = 5e-7/4; // default used in App1 UI; can be overridden in renderCurve(opts)
      const TmK = (dH*1000)/(dS + R*Math.log(Ct));
      return TmK - 273.15 + 16.6*log10(Math.max(saltM,1e-6));
    }

    function localTms(seq, concM, saltM, windowSize){
      const n = seq.length, half = Math.floor(windowSize/2);
      const tms = new Array(n).fill(NaN);
      for (let i=0;i<n;i++){
        const start = Math.max(0, i-half);
        const end   = Math.min(n, start+windowSize);
        tms[i] = computeTm(seq.slice(start, end), concM, saltM);
      }
      return tms;
    }

    function meltProb(T, Tm, k){ return 1/(1+Math.exp(-(T - Tm)/k)); }
    function probsFromTms(tms, T){ const k = 0.8; return tms.map(tm => isFinite(tm)? meltProb(T, tm, k): NaN); }

    function avgProbAtT(dataset, T){
      const probs = probsFromTms(dataset.tms, T);
      return probs.reduce((a,b)=>a+(isFinite(b)?b:0),0)/Math.max(1, probs.length);
    }

    function estimateTm(dataset){
      // Find temperature where average fraction melted crosses 0.5 via sweep
      const Tmin = state.Tmin, Tmax = state.Tmax, steps = 400;
      let bestT = NaN, bestErr = 1e9;
      for (let i=0;i<=steps;i++){
        const T = Tmin + (i/steps)*(Tmax-Tmin);
        const f = avgProbAtT(dataset, T);
        const err = Math.abs(f - 0.5);
        if (err < bestErr){ bestErr = err; bestT = T; }
      }
      return bestT;
    }

    function setDatasets(dsets){ state.datasets = dsets; draw(); updateDeltaTm(); }

    function draw(){
      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth, cssH = canvas.clientHeight;
      if (canvas.width !== Math.floor(cssW*dpr) || canvas.height !== Math.floor(cssH*dpr)){
        canvas.width = Math.floor(cssW*dpr); canvas.height= Math.floor(cssH*dpr);
      }
      ctx.setTransform(dpr,0,0,dpr,0,0);

      const W = cssW, H = cssH; const x0=40, x1=W-20, y0=H-20, y1=20;
      ctx.clearRect(0,0,W,H); ctx.fillStyle = '#0b1220'; ctx.fillRect(0,0,W,H);

      // grid
      ctx.strokeStyle='rgba(255,255,255,0.15)'; ctx.lineWidth=1;
      for(let i=0;i<=5;i++){ const y=y0-(y0-y1)*(i/5); ctx.beginPath(); ctx.moveTo(x0,y); ctx.lineTo(x1,y); ctx.stroke(); }
      ctx.fillStyle='#cbd5e1'; ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial';
      ctx.fillText('Fraction melted', 8, y1-6);
      ctx.fillText(`${state.Tmin}°C`, x0, y0+14); ctx.fillText(`${state.Tmax}°C`, x1-36, y0+14);
      for(let i=0;i<=5;i++){ const f=i/5; const y=y0-(y0-y1)*f; ctx.fillText(f.toFixed(1), 8, y+4); }

      const Tcur = +tempEl.value;
      const N=220;
      function pathFor(dataset){
        ctx.beginPath();
        for(let i=0;i<=N;i++){
          const T = state.Tmin + (i/N)*(state.Tmax-state.Tmin);
          const f = avgProbAtT(dataset, T);
          const x = x0 + (x1-x0)*(i/N);
          const y = y0 - (y0-y1)*f;
          if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
      }

      state.datasets.forEach(ds => { pathFor(ds); ctx.strokeStyle = ds.color; ctx.lineWidth=2; ctx.stroke(); });

      // vertical cursor aligned to slider
      const styles = getComputedStyle(tempEl); const thumbPx = parseFloat(styles.getPropertyValue('--thumb'))||12;
      const trackW = tempEl.clientWidth - thumbPx; const frac = Math.min(1, Math.max(0, (Tcur - state.Tmin)/(state.Tmax-state.Tmin)));
      const thumbCenterX = (frac*trackW) + thumbPx/2; const gx = x0 + (x1-x0) * (thumbCenterX/(trackW+thumbPx));
      ctx.save(); ctx.globalAlpha=.9; ctx.setLineDash([5,5]); ctx.strokeStyle='#ffffff'; ctx.beginPath(); ctx.moveTo(gx,y1); ctx.lineTo(gx,y0); ctx.stroke(); ctx.restore();
    }

    function updateDeltaTm(){
      if (state.datasets.length<2){ deltaEl.textContent='—'; return; }
      const tma = estimateTm(state.datasets[0]);
      const tmb = estimateTm(state.datasets[1]);
      if (isFinite(tma)&&isFinite(tmb)) deltaEl.textContent = Math.abs(tma-tmb).toFixed(2)+ '°C'; else deltaEl.textContent='—';
    }

    function renderCurve(label, seq, options={}){
      const salt = Math.max(1e-6, options.salt ?? 0.050);
      const conc = Math.max(1e-12, options.conc ?? 5e-7);
      let win = Math.max(5, Math.min(51, Math.floor(options.window ?? 15))); if (win % 2 === 0) win += 1;
      const tms = localTms(seq, conc, salt, win);
      const color = label==='A' ? '#38bdf8' : '#a78bfa';
      const ex = { label, seq, tms, color };
      // Replace existing label if present
      const idx = state.datasets.findIndex(d=>d.label===label);
      if (idx>=0) state.datasets[idx]=ex; else state.datasets.push(ex);
      draw(); updateDeltaTm();
    }

    function clear(){ state.datasets = []; draw(); updateDeltaTm(); }

    window.Simulator = { renderCurve, clear, estimateTm, setDatasets, localTms, computeTm };

    tempEl.addEventListener('input', ()=>{ document.getElementById('tLabel').textContent = tempEl.value; draw(); });
    window.addEventListener('resize', ()=>{ draw(); });
    // extra: observe element size changes to avoid black canvas on layout shifts
    new ResizeObserver(()=> draw()).observe(canvas.parentElement);
  })();

  /* =====================================
   * 2) Exercise engine (config + random)
   * ===================================== */
  (function(){
    const exIdEl = document.getElementById('exId');
    const promptEl = document.getElementById('prompt');
    const qsEl = document.getElementById('questions');
    const scoreEl = document.getElementById('score');

    const scenarioSel = document.getElementById('scenario');
    const lenEl = document.getElementById('len');
    const mutEl = document.getElementById('mut');
    const gcEl  = document.getElementById('gc');
    const tolEl = document.getElementById('gctol');
    const randomizeSel = document.getElementById('randomize');

    const swapBtn = document.getElementById('swap');
    const newBtn = document.getElementById('newset');
    const submitBtn = document.getElementById('submit');

    const DEFAULT_OPTS = { salt: 0.050, conc: 5e-7, window: 15 };

    // Salt controls (shown only for salt scenario)
    const saltControls = document.createElement('div');
    saltControls.className='row';
    saltControls.innerHTML = `
      <div style="flex:1">
        <label>High salt (M)</label>
        <input id="saltHi" type="number" step="0.01" value="0.15" min="0.005" max="1" />
      </div>
      <div style="flex:1">
        <label>Low salt (M)</label>
        <input id="saltLo" type="number" step="0.001" value="0.01" min="0.001" max="0.5" />
      </div>`;

    const SCENARIOS = [
      {
        id: 'variant-call',
        title: 'Variant Calling — Wild‑type vs SNV',
        prompt: (ctx)=>`Clinical lab context: you amplified a ${ctx.len}-bp region from a patient (sample B) and from a known healthy control (sample A). A single‑nucleotide variant may be present. Compare the melting curves to decide which is the wild‑type control and estimate ΔTm. Remember: identical GC% can still yield different Tm due to nearest‑neighbor stacking.`,
        questions: [
          { id:'q1', type:'single', text:'Which sample is wild‑type?', choices:['A (WT)','B (Variant)'], answer: (ctx)=>'A (WT)' },
          { id:'q2', type:'number', text:'Estimate ΔTm = |Tm(A) − Tm(B)| (°C). (±0.6°C)', answer:(ctx)=>ctx.delta, tolerance:0.6 },
          { id:'q3', type:'single', text:'Best explanation for identical GC% but different Tm', choices:[
              'Nearest‑neighbor stacking context changes ΔH/ΔS',
              'If GC% is equal, Tm must be equal',
              'Same length means same Tm'
            ], answer: 'Nearest‑neighbor stacking context changes ΔH/ΔS' },
        ],
        hint: 'Look for which curve melts at a higher temperature (shift to the right) — that is typically the wild‑type if the mutation destabilizes the duplex.',
        gen: (params)=> generatePair(params)
      },
      {
        id: 'strain-typing',
        title: 'Strain Typing — Lineage Assignment',
        prompt: (ctx)=>`Epidemiology lab: two isolates (A & B) of the same virus were amplified across a lineage‑informative motif. One lineage is slightly more stable due to motif changes. Use the curves to choose which is lineage X (the more stable one), estimate ΔTm, and reason about why.`,
        questions: [
          { id:'q1', type:'single', text:'Which sample corresponds to lineage X (higher stability)?', choices:['A','B'], answer:(ctx)=> ctx.tmxA>ctx.tmxB? 'A':'B' },
          { id:'q2', type:'number', text:'Estimate ΔTm (±0.6°C)', answer:(ctx)=>ctx.delta, tolerance:0.6 },
          { id:'q3', type:'single', text:'Which change most often raises Tm?', choices:['Longer duplex length (same composition)','Lower salt','More A/T steps at ends'], answer:'Longer duplex length (same composition)' },
        ],
        hint: 'Higher Tm (right‑shifted curve) ↔ more stable duplex. Small motif differences can change stacking energies.',
        gen: (params)=> generatePair(params)
      },
      {
        id: 'salt-effect',
        title: 'Ionic Strength — Salt Effect',
        prompt: (ctx)=>`Teaching lab: the same ${ctx.len}-bp sequence is run at two Na⁺ levels to demonstrate ionic shielding. Identify which curve is the high‑salt condition, estimate the shift, and explain why salt changes Tm.`,
        questions: [
          { id:'q1', type:'single', text:'Which sample is high‑salt?', choices:['A','B'], answer:(ctx)=> ctx.saltA>ctx.saltB? 'A':'B' },
          { id:'q2', type:'number', text:'Estimate |ΔTm| between high and low salt (±0.6°C)', answer:(ctx)=>ctx.delta, tolerance:0.6 },
          { id:'q3', type:'single', text:'Why does higher salt increase Tm?', choices:[
            'Salt shields phosphate repulsion and stabilizes the duplex',
            'Salt breaks hydrogen bonds and destabilizes the duplex',
            'Salt directly changes base sequence to add GC'
          ], answer: 'Salt shields phosphate repulsion and stabilizes the duplex' },
        ],
        hint: 'Higher salt screens negative charges on the backbone → less electrostatic repulsion → higher Tm.',
        gen: (params)=> generateSameSeqDifferentSalt(params)
      },
      {
        id: 'noisy-peaks',
        title: 'Noise & Peak Finding',
        prompt: (ctx)=>`Instrument output shows noisy derivative curves. Your task: infer the true Tm separation, pick a sensible smoothing strategy, and justify it.`,
        questions: [
          { id:'q1', type:'number', text:'Estimate ΔTm (±0.8°C)', answer:(ctx)=>ctx.delta, tolerance:0.8 },
          { id:'q2', type:'single', text:'Best way to improve clarity?', choices:['Smoothing / filtering','Use fewer replicates','Increase noise'], answer:'Smoothing / filtering' },
          { id:'q3', type:'single', text:'Which baseline step helps most for noisy fluorescence?', choices:['Baseline subtraction before derivative','Ignore baseline','Clip negative values only'], answer:'Baseline subtraction before derivative' },
        ],
        hint: 'Try averaging replicates and applying a gentle smoothing filter before derivative peak‑picking.',
        gen: (params)=> generatePair(params)
      }
    ];

    // Populate scenarios
    SCENARIOS.forEach(s=>{ const o=document.createElement('option'); o.value=s.id; o.textContent=s.title; scenarioSel.appendChild(o); });

    // ===== Random helpers =====
    function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
    function choice(ar){ return ar[Math.floor(Math.random()*ar.length)]; }

    function randomSequence(len, {gcTarget=0.5, gcTolerance=0.1}={}){
      len = Math.max(20, Math.floor(len));
      const minGC = Math.max(0, gcTarget - gcTolerance), maxGC = Math.min(1, gcTarget + gcTolerance);
      const bases = ['A','T','G','C'];
      for (let attempt=0; attempt<2000; attempt++){
        let s=''; let gc=0;
        for (let i=0;i<len;i++){
          const b = choice(bases); s+=b; if (b==='G'||b==='C') gc++;
        }
        const gcf = gc/len; if (gcf>=minGC && gcf<=maxGC) return s;
      }
      // Fallback: force GC close to target by construction
      const gcCount = Math.round(len*gcTarget);
      let arr = new Array(len).fill('A');
      for (let i=0;i<gcCount;i++){ arr[i] = (i%2? 'G':'C'); }
      for (let i=gcCount;i<len;i++){ arr[i] = (i%2? 'A':'T'); }
      // shuffle
      for (let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; }
      return arr.join('');
    }

    function mutateSequence(seq, n=1, centerBias=true){
      const comp = {A:['G','C','T'], T:['A','G','C'], G:['A','T','C'], C:['A','T','G']};
      const L = seq.length; const chosen = new Set();
      for(let k=0;k<n;k++){
        let idx;
        if (centerBias){
          // Gaussian-ish bias around center
          const mu = (L-1)/2; let candidate; let tries=0;
          do {
            const g = Math.min(3, Math.max(-3, (Math.random()*6)-3));
            candidate = Math.round(mu + g*(L*0.08));
            candidate = Math.max(0, Math.min(L-1, candidate));
            tries++;
          } while (chosen.has(candidate) && tries<50);
          idx = candidate;
        } else { idx = randInt(0,L-1); }
        chosen.add(idx);
      }
      const arr = seq.split('');
      chosen.forEach(i=>{ const b=arr[i]; const options = comp[b]||['A','T','G','C']; arr[i]= choice(options.filter(x=>x!==b)); });
      return { mutated: arr.join(''), positions: Array.from(chosen).sort((a,b)=>a-b) };
    }

    function gcFraction(seq){
      let gc = 0;
      for (const c of seq) { if (c==='G' || c==='C') gc++; }
      return gc / Math.max(1, seq.length);
    }

    function updateSeqPanel(ctx){
      const a = ctx.seqA || '';
      const b = ctx.seqB || '';
      const gca = (ctx.gcA ?? gcFraction(a));
      const gcb = (ctx.gcB ?? gcFraction(b));
      const seqAEl = document.getElementById('seqA');
      const seqBEl = document.getElementById('seqB');
      const gcAEl  = document.getElementById('gcA');
      const gcBEl  = document.getElementById('gcB');
      if (seqAEl) seqAEl.textContent = a || '—';
      if (seqBEl) seqBEl.textContent = b || '—';
      if (gcAEl)  gcAEl.textContent  = isFinite(gca)? (gca*100).toFixed(1)+'%':'—';
      if (gcBEl)  gcBEl.textContent  = isFinite(gcb)? (gcb*100).toFixed(1)+'%':'—';
    }

    // ===== Generators =====
    function generatePair(params){
      const len = Math.max(20, +lenEl.value || 36);
      const mut = Math.max(1, Math.min(3, +mutEl.value || 1));
      const gcTarget = Math.min(0.7, Math.max(0.3, +gcEl.value || 0.5));
      const gcTol = Math.min(0.3, Math.max(0.02, +tolEl.value || 0.1));

      const Aseq = randomSequence(len, {gcTarget, gcTolerance: gcTol});
      const mutRes = mutateSequence(Aseq, mut, true);
      const Bseq = mutRes.mutated;

      const ctx = {
        len, mut,
        seqA: Aseq, seqB: Bseq,
        gcA: gcFraction(Aseq), gcB: gcFraction(Bseq)
      };

      // Render via App1 engine
      window.Simulator.clear();
      window.Simulator.renderCurve('A', ctx.seqA, DEFAULT_OPTS);
      window.Simulator.renderCurve('B', ctx.seqB, DEFAULT_OPTS);

      // Estimate Tm for answers
      const dsets = [
        {label:'A', seq:ctx.seqA, tms: window.Simulator.localTms(ctx.seqA, DEFAULT_OPTS.conc, DEFAULT_OPTS.salt, DEFAULT_OPTS.window)},
        {label:'B', seq:ctx.seqB, tms: window.Simulator.localTms(ctx.seqB, DEFAULT_OPTS.conc, DEFAULT_OPTS.salt, DEFAULT_OPTS.window)}
      ];
      const tma = window.Simulator.estimateTm(dsets[0]);
      const tmb = window.Simulator.estimateTm(dsets[1]);
      ctx.tmxA = tma; ctx.tmxB = tmb; ctx.delta = Math.abs(tma-tmb);

      // Randomly assign which is wild-type for pedagogy? Keep A as wild-type by default here
      ctx.wtLabel = 'A';
      ctx.meta = { positions: mutRes.positions };
      updateSeqPanel(ctx);
      return ctx;
    }

    function generateSameSeqDifferentSalt(params){
      const len = Math.max(20, +lenEl.value || 36);
      const gcTarget = Math.min(0.7, Math.max(0.3, +gcEl.value || 0.5));
      const gcTol = Math.min(0.3, Math.max(0.02, +tolEl.value || 0.1));
      const seq = randomSequence(len, {gcTarget, gcTolerance: gcTol});
      const hiEl = document.getElementById('saltHi');
      const loEl = document.getElementById('saltLo');
      const saltHi = Math.max(1e-6, +(hiEl && hiEl.value ? hiEl.value : 0.150));
      const saltLo = Math.max(1e-6, +(loEl && loEl.value ? loEl.value : 0.010));

      const ctx = { len, seqA: seq, seqB: seq, saltA: saltHi, saltB: saltLo };
      window.Simulator.clear();
      window.Simulator.renderCurve('A', ctx.seqA, { ...DEFAULT_OPTS, salt: saltHi });
      window.Simulator.renderCurve('B', ctx.seqB, { ...DEFAULT_OPTS, salt: saltLo });

      const dA = {label:'A', seq:ctx.seqA, tms: window.Simulator.localTms(ctx.seqA, DEFAULT_OPTS.conc, saltHi, DEFAULT_OPTS.window)};
      const dB = {label:'B', seq:ctx.seqB, tms: window.Simulator.localTms(ctx.seqB, DEFAULT_OPTS.conc, saltLo, DEFAULT_OPTS.window)};
      ctx.tmxA = window.Simulator.estimateTm(dA); ctx.tmxB = window.Simulator.estimateTm(dB); ctx.delta = Math.abs(ctx.tmxA-ctx.tmxB);
      ctx.wtLabel = ctx.tmxA>ctx.tmxB ? 'A' : 'B';
      updateSeqPanel(ctx);
      return ctx;
    }

    // ===== Questions & scoring =====
    function renderQuestions(scn, ctx){
      exIdEl.textContent = scn.id;
      promptEl.textContent = typeof scn.prompt==='function' ? scn.prompt(ctx) : scn.prompt;
      qsEl.innerHTML = '';
      scn.questions.forEach((q, idx)=>{
        const div = document.createElement('div'); div.className='q';
        div.dataset.qid = q.id; div.innerHTML = `<div style="font-weight:700">Q${idx+1}. ${q.text}</div>`;
        if (q.type==='single'){
          const wrapper=document.createElement('div');
          q.choices.forEach((c,j)=>{ const id=`${q.id}_${j}`; const lab=document.createElement('label'); lab.style.display='block'; lab.innerHTML=`<input type="radio" name="${q.id}" value="${c}" id="${id}"> ${c}`; wrapper.appendChild(lab); });
          div.appendChild(wrapper);
        } else if (q.type==='number'){
          const inp=document.createElement('input'); inp.type='number'; inp.step='0.1'; inp.placeholder='Enter °C'; inp.className='mono'; div.appendChild(inp);
        } else if (q.type==='text'){
          const ta=document.createElement('textarea'); ta.rows=2; ta.placeholder='Type your short answer...'; div.appendChild(ta);
        }
        qsEl.appendChild(div);
      });
    }

    function grade(scn, ctx){
      let correct=0, total=scn.questions.length; const results=[];
      scn.questions.forEach(q=>{
        const node = qsEl.querySelector(`[data-qid="${q.id}"]`);
        let ok=false, got=null, exp=null;
        if (q.type==='single'){
          const sel=node.querySelector('input[type="radio"]:checked'); got=sel? sel.value: null; exp = typeof q.answer==='function'? q.answer(ctx): q.answer; ok = (got===exp);
        } else if (q.type==='number'){
          const val = node.querySelector('input').value.trim(); const num = Number(val); got = isFinite(num)? num : null; exp = typeof q.answer==='function'? q.answer(ctx): q.answer; const tol = q.tolerance ?? 0.5; ok = got !== null && Math.abs(num-exp) <= tol;
        } else if (q.type==='text'){
          const val = node.querySelector('textarea').value.toLowerCase(); got = val; const kws=(q.keywords||[]).map(x=>x.toLowerCase()); ok = kws.length? kws.every(k=>val.includes(k)) : !!val;
        }
        if (ok) correct++; results.push({id:q.id, ok, got, exp});
      });
      const pct = Math.round((correct/total)*100);
      scoreEl.innerHTML = `Score: <b class="${pct>=70?'good':'bad'}">${correct}/${total} (${pct}%)</b>`;
      return results;
    }

    // ===== Wiring =====
    let currentScenario = SCENARIOS[0];
    let currentCtx = null;

    function build(){
      const id = scenarioSel.value; currentScenario = SCENARIOS.find(s=>s.id===id) || SCENARIOS[0];
      // Show/hide salt controls based on scenario
      const cfgPanel = document.querySelector('.card .bd');
      const existing = cfgPanel.querySelector('#saltHi');
      if (currentScenario.id === 'salt-effect'){
        if (!existing) cfgPanel.insertBefore(saltControls, document.getElementById('randomize').parentElement);
      } else {
        if (existing) saltControls.remove();
      }
      currentCtx = currentScenario.gen({});
      updateSeqPanel(currentCtx);
      renderQuestions(currentScenario, currentCtx);
      // Set hint content
      document.getElementById('hintContent').textContent = currentScenario.hint || 'No hint for this scenario.';
    }

    scenarioSel.addEventListener('change', build);
    newBtn.addEventListener('click', build);
    swapBtn.addEventListener('click', ()=>{
      if (!currentCtx) return;
      // Swap datasets visually
      const A = {label:'A', seq:currentCtx.seqB, tms: window.Simulator.localTms(currentCtx.seqB, 5e-7, 0.050, 15)};
      const B = {label:'B', seq:currentCtx.seqA, tms: window.Simulator.localTms(currentCtx.seqA, 5e-7, 0.050, 15)};
      window.Simulator.setDatasets([A,B]);
      // Keep grading consistent by swapping keys too
      [currentCtx.seqA, currentCtx.seqB] = [currentCtx.seqB, currentCtx.seqA];
      [currentCtx.tmxA, currentCtx.tmxB] = [currentCtx.tmxB, currentCtx.tmxA];
      currentCtx.delta = Math.abs(currentCtx.tmxA - currentCtx.tmxB);
      currentCtx.wtLabel = currentCtx.wtLabel==='A' ? 'B' : 'A';
      updateSeqPanel(currentCtx);
    });

    submitBtn.addEventListener('click', ()=>{ if (!currentScenario||!currentCtx) return; grade(currentScenario, currentCtx); });

    // hint modal wiring
    document.getElementById('hint').addEventListener('click', ()=>{ document.getElementById('hintModal').style.display='flex'; });
    document.getElementById('closeHint').addEventListener('click', ()=>{ document.getElementById('hintModal').style.display='none'; });

    // uMelt popup
    document.getElementById('umelt').addEventListener('click', (e)=>{
      e.preventDefault();
      const w = 980, h = 760;
      const y = Math.max(0, (window.outerHeight - h) / 2 + window.screenY);
      const x = Math.max(0, (window.outerWidth  - w) / 2 + window.screenX);
      window.open('https://www.dna-utah.org/umelt/quartz/','uMelt','popup=yes,noopener,noreferrer,width='+w+',height='+h+',left='+x+',top='+y);
    });

    // Auto-start
    scenarioSel.value = 'variant-call';
    build();

    // extra test: salt effect should produce nonzero ΔTm for hi>lo (typical)
    (function testSalt(){
      const a=generateSameSeqDifferentSalt({});
      console.assert(isFinite(a.delta) && a.delta>=0, 'Salt scenario ΔTm should be finite');
    })();

    // ===== Self-tests (basic) =====
    (function runSelfTests(){
      try {
        const seq = randomSequence(30, {gcTarget:0.5, gcTolerance:0.1});
        console.assert(seq.length >= 20, 'Seq length should be >= 20');
        const gcf = gcFraction(seq);
        console.assert(gcf >= 0.4 && gcf <= 0.6, 'GC% within target ± tol');
        const m = mutateSequence(seq, 2, true);
        console.assert(m.mutated.length === seq.length, 'Mutated length equals original');
        console.assert(m.positions.length === 2, 'Two mutations applied');
        console.log('%cSelf‑tests passed','color:#22c55e');
      } catch (e) {
        console.warn('Self‑tests failed', e);
      }
    })();
  })();

  /* =====================================
   * 3) (Optional) Simple internal cross‑check
   *    Not uMelt — but a secondary Tm estimator to sanity‑check
   * ===================================== */
  // For now we use the same NN model with a coarse sweep — serves as a consistency check.
  // Hook available as window.CrossCheck.estimateDelta(seqA, seqB)
  (function(){
    function estimateDelta(seqA, seqB){
      try {
        const dA = {label:'A', seq:seqA, tms: window.Simulator.localTms(seqA, 5e-7, 0.050, 15)};
        const dB = {label:'B', seq:seqB, tms: window.Simulator.localTms(seqB, 5e-7, 0.050, 15)};
        const tma = window.Simulator.estimateTm(dA); const tmb = window.Simulator.estimateTm(dB);
        return Math.abs(tma - tmb);
      } catch(e){ return NaN; }
    }
    window.CrossCheck = { estimateDelta };
  })();
  </script>
</body>
</html>
